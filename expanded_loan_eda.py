# -*- coding: utf-8 -*-
"""Expanded_Loan_EDA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QCSh7melYZyTWSkooYN0DXqmRnyU31uE
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

df=pd.read_csv('/content/drive/MyDrive/Assignments/Expanded_Loan_Dataset.csv')
df.head(5)

df.tail(5)

print(df.shape)
print(df.columns)
print(df.info())
print(df.duplicated().sum())

"""# Analyzing Customer Base and conversion rate"""

# OR: Replace with absolute value
df['Experience'] = df['Experience'].abs()
df.describe()

# Select only numeric columns
numeric_columns = df.select_dtypes(include=['int64', 'float64']).columns

# Calculate the mode for numeric columns
for col in numeric_columns:
    print(f"Mode of {col}: {df[col].mode()[0]}")

numeric_columns = df.select_dtypes(include=['int64', 'float64'])
numeric_columns.var()

# Box plots for detecting outliers
numerical_columns = df.select_dtypes(include=['int64', 'float64']).columns

for col in numerical_columns:
    plt.figure(figsize=(10, 5))
    sns.boxplot(df[col])
    plt.title(f'Boxplot for {col}')
    plt.show()

# Numerical columns
numerical_columns = df.select_dtypes(include=['int64', 'float64']).columns

# Plotting distributions
for col in numerical_columns:
    plt.figure(figsize=(10, 5))
    sns.histplot(df[col], kde=True, bins=30)  # Bins are set to 30 for better resolution
    plt.title(f'Distribution of {col}')
    plt.show()

df['Loan_to_Income_Ratio'] = df['Loan_Amount'] / (df['Income'] + 1)  # Adding 1 to avoid division by zero
plt.figure(figsize=(10, 5))
sns.histplot(df['Loan_to_Income_Ratio'], kde=True, bins=30)
plt.title('Distribution of Loan to Income Ratio')
plt.show()

# Categorical columns
categorical_columns = df.select_dtypes(include=['object']).columns

# Checking unique values in categorical columns
for col in categorical_columns:
    print(f"{col} unique values:\n", df[col].value_counts(), "\n")

for col in categorical_columns:
    plt.figure(figsize=(10, 5))
    sns.countplot(x=col, data=df, hue=col, dodge=False, legend=False)  # Set hue to x and disable legend
    plt.title(f'Count Plot of {col}')
    plt.xticks(rotation=45, ha='right')
    plt.show()

# Correlation matrix and heatmap
plt.figure(figsize=(12, 8))
sns.heatmap(df.corr(numeric_only=True), annot=True, cmap='coolwarm', linewidths=0.5)
plt.title('Correlation Heatmap')
plt.show()

# Descriptive statistics for converters
converted_customers = df[df['PersonalLoan'] == 1]
non_converted_customers = df[df['PersonalLoan'] == 0]

print("Converted Customers:\n", converted_customers.describe(), "\n")
print("Non-Converted Customers:\n", non_converted_customers.describe())

# Distribution of Income for converted vs. non-converted
plt.figure(figsize=(12, 6))
sns.histplot(data=converted_customers, x='Income', color='green', label='Converted', kde=True, bins=30)
sns.histplot(data=non_converted_customers, x='Income', color='red', label='Not Converted', kde=True, bins=30)
plt.title('Income Distribution: Converted vs Non-Converted')
plt.legend()
plt.show()

# Define income bins
income_bins = [0, 50, 100, 150, 200, np.inf]
df['Income_Group'] = pd.cut(df['Income'], bins=income_bins, labels=['0-50', '50-100', '100-150', '150-200', '200+'])

# Conversion rate by income group
conversion_by_income = pd.crosstab(df['Income_Group'], df['PersonalLoan'])
conversion_by_income = conversion_by_income.div(conversion_by_income.sum(1), axis=0)  # Convert to percentage
conversion_by_income.plot(kind='bar', stacked=True, figsize=(10, 6), cmap='coolwarm')
plt.title('Personal Loan Conversion Rate by Income Group')
plt.xlabel('Income Group')
plt.ylabel('Conversion Rate')
plt.show()

"""# Customer Behaviour"""

unique_incomes = df['Income'].unique()
sorted_unique_incomes = np.sort(unique_incomes)
print(sorted_unique_incomes)
unique_ages = df['Age'].unique()
sorted_unique_ages = np.sort(unique_ages)
print(sorted_unique_ages)

income_bins = [0, 50, 100, 150, 200, np.inf]
df['Income_Group'] = pd.cut(df['Income'], bins=income_bins, labels=['0-50', '50-100', '100-150', '150-200', '200+'])
plt.figure(figsize=(10, 5))
sns.boxplot(x='Income_Group', y='Loan_Amount', data=df)
plt.title('Income Group vs Loan Amount')
plt.xticks(rotation=45)
plt.show()

# Define income bins based on your data distribution
age_bins = [20, 30, 40, 50, 60, np.inf]
df['Age_Group'] = pd.cut(df['Age'], bins=age_bins, labels=['20-30', '30-40', '40-50', '50-60', '60+'])
plt.figure(figsize=(10, 5))
sns.boxplot(x='Age_Group', y='Loan_Amount', data=df)
plt.title('Age Group vs Loan Amount')
plt.xticks(rotation=45)
plt.show()

age_bins = [20, 30, 40, 50, 60, np.inf]
df['Age_Group'] = pd.cut(df['Age'], bins=age_bins, labels=['20-30', '30-40', '40-50', '50-60', '60+'])
plt.figure(figsize=(10, 5))
sns.boxplot(x='Age_Group', y='Income', data=df)
plt.title('Income vs Age')
plt.show()


plt.figure(figsize=(10, 5))
sns.boxplot(x='Marital_Status', y='Loan_Amount', data=df)
plt.title('Loan Amount vs Marital Status')
plt.show()


plt.figure(figsize=(10, 5))
sns.boxplot(x='Education', y='Loan_Amount', data=df)
plt.title('Loan Amount vs Education')
plt.show()

# Identifying numerical columns (excluding categorical features)
numerical_columns = ['Age', 'Experience', 'Income', 'Family', 'CCAvg', 'Mortgage', 'Loan_Amount']

# Handling outliers using IQR (Interquartile Range)
Q1 = df[numerical_columns].quantile(0.25)
Q3 = df[numerical_columns].quantile(0.75)
IQR = Q3 - Q1
# Removing outliers
df1 = df[~((df[numerical_columns] < (Q1 - 1.5 * IQR)) | (df[numerical_columns] > (Q3 + 1.5 * IQR))).any(axis=1)]

# Correlation with target variable
plt.figure(figsize=(10, 5))
sns.heatmap(df1.corr(numeric_only=True)[['PersonalLoan']].sort_values(by='PersonalLoan', ascending=False), annot=True, cmap='coolwarm')
plt.title('Correlation of Features with Personal Loan')
plt.show()

# Pair plot for features related to personal loan acceptance
sns.pairplot(df, vars=['Age', 'Income', 'Loan_Amount', 'CCAvg', 'Mortgage', 'Experience'], hue='PersonalLoan')
plt.show()

"""# Finding Cross Selling Opportunity"""

plt.figure(figsize=(10, 5))
sns.countplot(x='CDAccount', hue='CreditCard', data=df)
plt.title('CD Accounts vs Credit Card Usage')
plt.show()

plt.figure(figsize=(10, 5))
sns.countplot(x='Online', hue='CreditCard', data=df)
plt.title('Online Services vs Credit Card Usage')
plt.show()

plt.figure(figsize=(10, 5))
sns.countplot(x='Gender', hue='CDAccount', data=df)
plt.title('Gender vs CD Account Usage')
plt.show()

plt.figure(figsize=(10, 5))
sns.countplot(x='Gender', hue='Securities.Account', data=df)
plt.title('Gender vs Security Account Usage')
plt.show()

loan_by_state = pd.crosstab(df['State'], df['PersonalLoan'])
loan_by_state.plot(kind='bar', stacked=True)
plt.title('Loan Acceptance by State')
plt.xlabel('State')
plt.ylabel('Count')
plt.show()

loan_by_area = pd.crosstab(df['Rural_Urban'], df['PersonalLoan'])
loan_by_area.plot(kind='bar', stacked=True)
plt.title('Loan Acceptance by Area (Rural/Urban)')
plt.xlabel('Rural/Urban')
plt.ylabel('Count')
plt.show()

pd.crosstab(df['Marital_Status'], df['CDAccount']).plot(kind='bar', stacked=True)
plt.title('Marital Status vs CD Accounts')
plt.xlabel('Marital Status')
plt.ylabel('Count')
plt.show()

pd.crosstab(df['Marital_Status'], df['Securities.Account']).plot(kind='bar', stacked=True)
plt.title('Marital Status vs Security Accounts')
plt.xlabel('Marital Status')
plt.ylabel('Count')
plt.show()

pd.crosstab([df['Gender'], df['Marital_Status']], df['CreditCard']).plot(kind='bar', stacked=True)
plt.title('Gender and Marital Status vs Credit Card Usage')
plt.xlabel('Gender and Marital Status')
plt.ylabel('Count')
plt.show()

product_columns = ['CDAccount', 'Security.Account', 'CreditCard', 'Online']

# Create a new column 'Multiple_Product_Usage' by summing up binary indicators for product usage
df['Multiple_Product_Usage'] = df[product_columns].sum(axis=1)

# Inspect the new column
print(df[['CD_Account', 'Security_Account', 'Credit_Card_Usage', 'Online_Services', 'Multiple_Product_Usage']].head())

product_columns = ['CDAccount', 'Securities.Account', 'CreditCard', 'Online']

# Create a new column 'Multiple_Product_Usage' by summing up binary indicators for product usage
df['Multiple_Product_Usage'] = df[product_columns].sum(axis=1)
# Inspect the new column
print(df[['CDAccount', 'Securities.Account', 'CreditCard', 'Online', 'Multiple_Product_Usage']].head())

sns.countplot(x='Multiple_Product_Usage', data=df)
plt.title('Distribution of Multiple Product Usage')
plt.xlabel('Number of Products Used')
plt.ylabel('Count')
plt.show()

pd.crosstab(df['Marital_Status'], df['Multiple_Product_Usage']).plot(kind='bar', stacked=True)
plt.title('Marital Status vs Multiple Product Usage')
plt.xlabel('Marital Status')
plt.ylabel('Count')
plt.show()

# Creating Age Bins (e.g., 18-30, 31-40, etc.)
bins = [18, 30, 40, 50, 60, 70]
labels = ['18-30', '31-40', '41-50', '51-60', '61-70']
df1['Age_Group'] = pd.cut(df1['Age'], bins=bins, labels=labels, right=False)

# Cross-tabulation of Age Groups and Personal Loan
loan_by_age_group = pd.crosstab(df1['Age_Group'], df1['PersonalLoan'])

# Plotting the distribution of personal loan acceptance by age group
loan_by_age_group.plot(kind='bar', stacked=True, figsize=(10, 6), cmap='coolwarm')
plt.title('Personal Loan Acceptance by Age Group')
plt.xlabel('Age Group')
plt.ylabel('Count')
plt.show()

from statsmodels.stats.outliers_influence import variance_inflation_factor

from statsmodels.stats.outliers_influence import variance_inflation_factor

# Calculating VIF for numerical features
X = df[numerical_columns]
vif = pd.DataFrame()
vif['Features'] = X.columns
vif['VIF'] = [variance_inflation_factor(X.values, i) for i in range(X.shape[1])]
print(vif)

# Remove features with high VIF
high_vif_features = vif[vif['VIF'] > 10]['Features']
X_reduced = X.drop(columns=high_vif_features)

# Recalculate VIF after removing high VIF features
vif_reduced = pd.DataFrame()
vif_reduced['Features'] = X_reduced.columns
vif_reduced['VIF'] = [variance_inflation_factor(X_reduced.values, i) for i in range(X_reduced.shape[1])]
print(vif_reduced)